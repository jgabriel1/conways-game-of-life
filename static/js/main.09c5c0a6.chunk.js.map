{"version":3,"sources":["interface/hooks/dimension.tsx","core/Cell.ts","core/Grid.ts","core/adapters/CellChangeObserver.ts","core/adapters/ObservableCell.ts","core/adapters/GridWithImage.ts","core/util/generateRiggedBoolean.ts","core/Game.ts","core/factories/createGameWithImage.ts","core/factories/createGame.ts","interface/hooks/game.tsx","interface/hooks/index.tsx","interface/components/Cell.tsx","interface/components/Grid.tsx","interface/components/TopBar.tsx","interface/components/AppContainer.tsx","interface/styles/theme.ts","interface/App.tsx","interface/index.tsx"],"names":["DimensionsContext","createContext","DimensionsProvider","children","height","window","innerHeight","width","innerWidth","cellsHorizontal","Math","floor","cellsVertical","Provider","value","cellDimension","useDimensions","useContext","Cell","isAlive","neighbors","this","neighbor","push","Grid","grid","shouldWrapAround","buildNeighborhoodNetwork","x","y","correctedX","correctedY","forEach","row","j","cell","i","neighborIndex","getCell","addNeighbor","setIsAlive","callback","map","Array","from","CellChangeObserver","cellChanged","ObservableCell","cellObserver","notifyCellChanged","GridWithImage","image","cellChangeObserver","onImageUpdateCallback","buildImage","executeCallback","resetCellChanged","toggleCell","currentValue","rebuildImage","getCellChanged","mappedGrid","cellArray","cellIsAlive","rigFactor","random","generateRiggedBoolean","Game","mainGrid","offGrid","refreshRate","timeout","clearInterval","setInterval","rowIndex","cellIndex","mainGridState","offGridCell","nextState","getNextLifeStatus","mainGridCell","aliveNeighbors","getNeighbors","reduce","accum","createGameWithImage","gridWithImage","gridHeight","gridWidth","gridType","rest","createRandom","create","getImage","mainGridFactory","offGridFactory","createGame","GameContext","GameProvider","useState","setGrid","game","setGame","isRunning","gameIsRunning","setGameIsRunning","generateRandomGame","useCallback","newGame","resetGame","toggleGame","stop","run","current","useGame","AppProvider","memo","dimension","coordinates","isClicked","onMouseEnter","onMouseDown","border","borderColor","borderRadius","h","w","bg","oldProps","newProps","isMouseDown","setIsMouseDown","align","justify","flex","templateColumns","templateRows","onMouseUp","onMouseLeave","String","TopBar","isScreenWide","useBreakpointValue","base","md","px","as","maxW","mx","color","size","fontWeight","gridGap","type","onClick","colorScheme","aria-label","icon","fontSize","disabled","variant","IconButton","minW","AppContainer","flexDir","theme","extendTheme","fonts","heading","body","App","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.09c5c0a6.chunk.js","sourcesContent":["import React, { createContext, useContext } from 'react';\n\ninterface DimensionsContextData {\n  cellsHorizontal: number;\n  cellsVertical: number;\n  cellDimension: number;\n}\n\nconst DimensionsContext = createContext<DimensionsContextData>(\n  {} as DimensionsContextData,\n);\n\nconst MINIMUM_CELL_DIMENSION = 32;\n\nconst DimensionsProvider: React.FC = ({ children }) => {\n  const height = window.innerHeight - 64;\n  const width = window.innerWidth - 64;\n\n  const cellDimension = MINIMUM_CELL_DIMENSION;\n\n  const cellsHorizontal = Math.floor(width / cellDimension);\n  const cellsVertical = Math.floor(height / cellDimension);\n\n  return (\n    <DimensionsContext.Provider\n      value={{ cellsHorizontal, cellsVertical, cellDimension }}\n    >\n      {children}\n    </DimensionsContext.Provider>\n  );\n};\n\nexport default DimensionsProvider;\n\nexport function useDimensions() {\n  return useContext(DimensionsContext);\n}\n","export class Cell {\n  public isAlive: boolean;\n\n  private neighbors: Cell[];\n\n  public constructor(isAlive = false) {\n    this.isAlive = isAlive;\n    this.neighbors = [];\n  }\n\n  public setIsAlive(isAlive: boolean): void {\n    this.isAlive = isAlive;\n  }\n\n  public getNeighbors(): Cell[] {\n    return this.neighbors;\n  }\n\n  public addNeighbor(neighbor: Cell): void {\n    this.neighbors.push(neighbor);\n  }\n}\n","import { Cell } from './Cell';\nimport { IGrid } from './IGrid';\n\nexport interface GridData {\n  width: number;\n  height: number;\n  shouldWrapAround?: boolean;\n}\n\nexport class Grid implements IGrid {\n  public constructor(\n    private grid: Cell[][],\n    private height: number,\n    private width: number,\n    private shouldWrapAround: boolean,\n  ) {\n    this.buildNeighborhoodNetwork();\n  }\n\n  public getCell(x: number, y: number): Cell | null {\n    if (!this.shouldWrapAround) {\n      if (x >= this.width || y >= this.height || x < 0 || y < 0) {\n        return null;\n      }\n\n      return this.grid[y][x];\n    }\n\n    let correctedX = x;\n    let correctedY = y;\n\n    if (x < 0) {\n      correctedX = this.width - 1;\n    } else if (x >= this.width) {\n      correctedX = 0;\n    }\n\n    if (y < 0) {\n      correctedY = this.height - 1;\n    } else if (y >= this.height) {\n      correctedY = 0;\n    }\n\n    return this.grid[correctedY][correctedX];\n  }\n\n  private buildNeighborhoodNetwork(): void {\n    this.grid.forEach((row, j) => {\n      row.forEach((cell, i) => {\n        const possibleNeighbors: Array<[number, number]> = [\n          [i - 1, j - 1],\n          [i - 1, j],\n          [i - 1, j + 1],\n          [i, j - 1],\n          [i, j + 1],\n          [i + 1, j - 1],\n          [i + 1, j],\n          [i + 1, j + 1],\n        ];\n\n        possibleNeighbors.forEach(neighborIndex => {\n          const neighbor = this.getCell(...neighborIndex);\n\n          if (neighbor) cell.addNeighbor(neighbor);\n        });\n      });\n    });\n  }\n\n  public toggleCell(x: number, y: number): void {\n    const cell = this.getCell(x, y);\n\n    cell?.setIsAlive(!cell.isAlive);\n  }\n\n  public forEach(callback: (row: Cell[], index: number) => void): void {\n    this.grid.forEach(callback);\n  }\n\n  public map<T>(callback: (row: Cell[], index: number) => T): T[] {\n    return this.grid.map(callback);\n  }\n\n  public static create({\n    height,\n    width,\n    shouldWrapAround = true,\n  }: GridData): Grid {\n    // Fill the each slot of the grid with a new instance of Cell\n    const cellArray = Array.from(Array(height), () =>\n      Array.from(Array(width), () => new Cell()),\n    );\n\n    const grid = new Grid(cellArray, height, width, shouldWrapAround);\n\n    return grid;\n  }\n}\n","export class CellChangeObserver {\n  private cellChanged: boolean;\n\n  public constructor(cellChanged = false) {\n    this.cellChanged = cellChanged;\n  }\n\n  public getCellChanged(): boolean {\n    return this.cellChanged;\n  }\n\n  public notifyCellChanged() {\n    this.cellChanged = true;\n  }\n\n  public resetCellChanged() {\n    this.cellChanged = false;\n  }\n}\n","import { Cell } from '../Cell';\nimport { CellChangeObserver } from './CellChangeObserver';\n\nexport class ObservableCell extends Cell {\n  private cellObserver: CellChangeObserver;\n\n  public constructor(isAlive = false, cellObserver: CellChangeObserver) {\n    super(isAlive);\n    this.cellObserver = cellObserver;\n  }\n\n  public setIsAlive(isAlive: boolean) {\n    super.setIsAlive(isAlive);\n\n    this.cellObserver.notifyCellChanged();\n  }\n}\n","import { Cell } from '../Cell';\nimport { Grid, GridData } from '../Grid';\nimport { IGrid } from '../IGrid';\nimport { generateRiggedBoolean } from '../util/generateRiggedBoolean';\nimport { CellChangeObserver } from './CellChangeObserver';\nimport { ObservableCell } from './ObservableCell';\n\nexport interface GridWithImageData extends GridData {\n  onImageUpdateCallback?: (image: boolean[][]) => void;\n}\n\nexport class GridWithImage implements IGrid {\n  private constructor(\n    private grid: Grid,\n    private image: boolean[][],\n    private cellChangeObserver: CellChangeObserver,\n    private onImageUpdateCallback?: (image: boolean[][]) => void,\n  ) {\n    this.buildImage();\n  }\n\n  public getImage() {\n    return this.image;\n  }\n\n  private executeCallback() {\n    if (this.onImageUpdateCallback) this.onImageUpdateCallback(this.image);\n  }\n\n  private buildImage() {\n    this.image = this.grid.map(row => row.map(cell => cell.isAlive));\n  }\n\n  private rebuildImage() {\n    this.buildImage();\n\n    this.executeCallback();\n\n    this.cellChangeObserver.resetCellChanged();\n  }\n\n  public getCell(x: number, y: number): Cell | null {\n    return this.grid.getCell(x, y);\n  }\n\n  public toggleCell(x: number, y: number): void {\n    this.grid.toggleCell(x, y);\n\n    const currentValue = this.image[y][x];\n\n    this.image[y][x] = !currentValue;\n\n    this.rebuildImage();\n  }\n\n  public forEach(callback: (row: Cell[], index: number) => void): void {\n    this.grid.forEach(callback);\n\n    const anyCellChanged = this.cellChangeObserver.getCellChanged();\n\n    if (anyCellChanged) {\n      this.rebuildImage();\n    }\n  }\n\n  public map<T>(callback: (row: Cell[], index: number) => T): T[] {\n    const mappedGrid = this.grid.map<T>(callback);\n\n    const anyCellChanged = this.cellChangeObserver.getCellChanged();\n\n    if (anyCellChanged) {\n      this.rebuildImage();\n    }\n\n    return mappedGrid;\n  }\n\n  public static create({\n    height,\n    width,\n    shouldWrapAround = true,\n    onImageUpdateCallback,\n  }: GridWithImageData): GridWithImage {\n    const cellChangeObserver = new CellChangeObserver();\n\n    const cellArray = Array.from(Array(height), () =>\n      Array.from(\n        Array(width),\n        () => new ObservableCell(false, cellChangeObserver),\n      ),\n    );\n\n    const grid = new Grid(cellArray, height, width, shouldWrapAround);\n\n    const gridWithImage = new GridWithImage(\n      grid,\n      [],\n      cellChangeObserver,\n      onImageUpdateCallback,\n    );\n\n    return gridWithImage;\n  }\n\n  public static createRandom({\n    height,\n    width,\n    shouldWrapAround = true,\n    onImageUpdateCallback,\n  }: GridWithImageData): GridWithImage {\n    const cellChangeObserver = new CellChangeObserver();\n\n    const cellArray = Array.from(Array(height), () =>\n      Array.from(Array(width), () => {\n        const cellIsAlive = generateRiggedBoolean(0.66);\n\n        return new ObservableCell(cellIsAlive, cellChangeObserver);\n      }),\n    );\n\n    const grid = new Grid(cellArray, height, width, shouldWrapAround);\n\n    const gridWithImage = new GridWithImage(\n      grid,\n      [],\n      cellChangeObserver,\n      onImageUpdateCallback,\n    );\n\n    return gridWithImage;\n  }\n}\n","export const generateRiggedBoolean = (rigFactor = 0.5): boolean => {\n  return Math.random() > rigFactor;\n};\n","import { Cell } from './Cell';\nimport { IGrid } from './IGrid';\n\nexport class Game {\n  public constructor(\n    private mainGrid: IGrid,\n    private offGrid: IGrid,\n    private refreshRate: number,\n    private timeout?: NodeJS.Timeout,\n  ) {}\n\n  public toggleCell(x: number, y: number) {\n    this.mainGrid.toggleCell(x, y);\n  }\n\n  public isRunning(): boolean {\n    return !!this.timeout;\n  }\n\n  public stop(): void {\n    if (this.timeout) {\n      clearInterval(this.timeout);\n\n      delete this.timeout;\n    }\n  }\n\n  public run(): void {\n    this.timeout = setInterval(() => {\n      // Copy data from the main grid to the off grid:\n      this.mainGrid.forEach((row, rowIndex) => {\n        row.forEach((cell, cellIndex) => {\n          const mainGridState = cell.isAlive;\n\n          const offGridCell = this.offGrid.getCell(cellIndex, rowIndex);\n\n          offGridCell?.setIsAlive(mainGridState);\n        });\n      });\n\n      // Modify the main grid based on the off grid state and game rules\n      this.offGrid.forEach((row, rowIndex) => {\n        row.forEach((cell, cellIndex) => {\n          const nextState = Game.getNextLifeStatus(cell);\n\n          const mainGridCell = this.mainGrid.getCell(cellIndex, rowIndex);\n\n          mainGridCell?.setIsAlive(nextState);\n        });\n      });\n    }, this.refreshRate);\n  }\n\n  private static getNextLifeStatus(cell: Cell): boolean {\n    const aliveNeighbors = cell\n      .getNeighbors()\n      .reduce((accum, neighbor) => (neighbor.isAlive ? accum + 1 : accum), 0);\n\n    if (aliveNeighbors === 3) return true;\n\n    if (aliveNeighbors === 2) return cell.isAlive;\n\n    return false;\n  }\n}\n","import { GridWithImage } from '../adapters/GridWithImage';\nimport { CreateGameOptions, createGame } from './createGame';\n\ninterface CreateGameWithImageOptions extends CreateGameOptions {\n  gridType: 'random' | 'clear';\n  onImageUpdateCallback: (image: boolean[][]) => void;\n}\n\nexport function createGameWithImage({\n  gridHeight,\n  gridWidth,\n  gridType,\n  onImageUpdateCallback,\n  ...rest\n}: CreateGameWithImageOptions) {\n  let gridWithImage: GridWithImage;\n\n  switch (gridType) {\n    case 'random':\n      gridWithImage = GridWithImage.createRandom({\n        height: gridHeight,\n        width: gridWidth,\n        shouldWrapAround: rest.shouldWrapAround,\n        onImageUpdateCallback,\n      });\n      break;\n\n    default:\n    case 'clear':\n      gridWithImage = GridWithImage.create({\n        height: gridHeight,\n        width: gridWidth,\n        shouldWrapAround: rest.shouldWrapAround,\n        onImageUpdateCallback,\n      });\n      break;\n  }\n\n  onImageUpdateCallback(gridWithImage.getImage());\n\n  const newGame = createGame({\n    mainGridFactory: () => gridWithImage,\n    gridHeight,\n    gridWidth,\n    ...rest,\n  });\n\n  return newGame;\n}\n","import { Game } from '../Game';\nimport { Grid } from '../Grid';\nimport { IGrid } from '../IGrid';\n\nexport interface CreateGameOptions {\n  gridHeight: number;\n  gridWidth: number;\n  mainGridFactory?: () => IGrid;\n  offGridFactory?: () => IGrid;\n  refreshRate?: number;\n  shouldWrapAround?: boolean;\n}\n\nexport function createGame({\n  mainGridFactory,\n  offGridFactory,\n  gridHeight,\n  gridWidth,\n  shouldWrapAround = true,\n  refreshRate = 200,\n}: CreateGameOptions): Game {\n  const mainGrid = mainGridFactory\n    ? mainGridFactory()\n    : Grid.create({\n        height: gridHeight,\n        width: gridWidth,\n        shouldWrapAround,\n      });\n\n  const offGrid = offGridFactory\n    ? offGridFactory()\n    : Grid.create({\n        height: gridHeight,\n        width: gridWidth,\n        shouldWrapAround,\n      });\n\n  return new Game(mainGrid, offGrid, refreshRate);\n}\n","import React, { createContext, useCallback, useContext, useState } from 'react';\nimport { Game } from '../../core/Game';\nimport { createGameWithImage } from '../../core/factories/createGameWithImage';\n\nimport { useDimensions } from './dimension';\n\ninterface GameContextData {\n  grid: boolean[][];\n  gameIsRunning: boolean;\n  resetGame: () => void;\n  generateRandomGame: () => void;\n  toggleCell: (x: number, y: number) => void;\n  toggleGame: () => void;\n}\n\nconst GameContext = createContext({} as GameContextData);\n\nconst GameProvider: React.FC = ({ children }) => {\n  const { cellsVertical, cellsHorizontal } = useDimensions();\n\n  const [grid, setGrid] = useState<boolean[][]>([]);\n\n  const [game, setGame] = useState<Game>(() => {\n    const newGame = createGameWithImage({\n      gridHeight: cellsVertical,\n      gridWidth: cellsHorizontal,\n      gridType: 'clear',\n      onImageUpdateCallback: image => setGrid(image),\n    });\n\n    return newGame;\n  });\n\n  const [gameIsRunning, setGameIsRunning] = useState(() => {\n    return game.isRunning();\n  });\n\n  const generateRandomGame = useCallback(() => {\n    /*\n      Return early if game is running. This could cause problems with internal\n      game logic. Simply blocking it for simplicity.\n    */\n    if (gameIsRunning) return;\n\n    const newGame = createGameWithImage({\n      gridHeight: cellsVertical,\n      gridWidth: cellsHorizontal,\n      gridType: 'random',\n      onImageUpdateCallback: image => setGrid(image),\n    });\n\n    setGame(newGame);\n  }, [cellsHorizontal, cellsVertical, gameIsRunning]);\n\n  const resetGame = useCallback(() => {\n    /*\n      Return early if game is running. This could cause problems with internal\n      game logic. Simply blocking it for simplicity.\n    */\n    if (gameIsRunning) return;\n\n    const newGame = createGameWithImage({\n      gridHeight: cellsVertical,\n      gridWidth: cellsHorizontal,\n      gridType: 'clear',\n      onImageUpdateCallback: image => setGrid(image),\n    });\n\n    setGame(newGame);\n  }, [cellsHorizontal, cellsVertical, gameIsRunning]);\n\n  const toggleCell = useCallback(\n    (x: number, y: number) => {\n      game.toggleCell(x, y);\n    },\n    [game],\n  );\n\n  const toggleGame = useCallback(() => {\n    game.isRunning() ? game.stop() : game.run();\n\n    setGameIsRunning(current => !current);\n  }, [game]);\n\n  return (\n    <GameContext.Provider\n      value={{\n        grid,\n        gameIsRunning,\n        resetGame,\n        generateRandomGame,\n        toggleCell,\n        toggleGame,\n      }}\n    >\n      {children}\n    </GameContext.Provider>\n  );\n};\n\nexport default GameProvider;\n\nexport function useGame() {\n  return useContext(GameContext);\n}\n","import React from 'react';\n\nimport DimensionsProvider from './dimension';\nimport GameProvider from './game';\n\nconst AppProvider: React.FC = ({ children }) => {\n  return (\n    <DimensionsProvider>\n      <GameProvider>{children}</GameProvider>\n    </DimensionsProvider>\n  );\n};\n\nexport default AppProvider;\n","import React, { memo } from 'react';\nimport { Box } from '@chakra-ui/react';\n\ninterface CellProps {\n  dimension: number;\n  coordinates: [number, number];\n  isAlive?: boolean;\n  isClicked?: boolean;\n  toggleCell: (x: number, y: number) => void;\n}\n\nexport const Cell: React.FC<CellProps> = memo(\n  ({ dimension, isAlive, coordinates: [x, y], toggleCell, isClicked }) => {\n    return (\n      <Box\n        onMouseEnter={() => isClicked && toggleCell(x, y)}\n        onMouseDown={() => toggleCell(x, y)}\n        border=\"1px\"\n        borderColor=\"whiteAlpha.300\"\n        borderRadius=\"sm\"\n        h={`${dimension}px`}\n        w={`${dimension}px`}\n        bg={isAlive ? 'gray.500' : 'gray.200'}\n      />\n    );\n  },\n  (oldProps, newProps) =>\n    oldProps.isAlive === newProps.isAlive &&\n    oldProps.isClicked === newProps.isClicked,\n);\n","import React, { useState } from 'react';\nimport { Flex, Grid as ChakraGrid } from '@chakra-ui/react';\n\nimport { useGame } from '../hooks/game';\nimport { useDimensions } from '../hooks/dimension';\n\nimport { Cell } from './Cell';\n\nexport const Grid: React.FC = () => {\n  const { grid, toggleCell } = useGame();\n  const { cellDimension, cellsVertical, cellsHorizontal } = useDimensions();\n\n  const [isMouseDown, setIsMouseDown] = useState(false);\n\n  return (\n    <Flex align=\"center\" justify=\"center\" bg=\"gray.100\" flex=\"1\">\n      <ChakraGrid\n        templateColumns={`repeat(${cellsHorizontal}, 1fr)`}\n        templateRows={`repeat(${cellsVertical}, 1fr)`}\n        onMouseDown={() => setIsMouseDown(true)}\n        onMouseUp={() => setIsMouseDown(false)}\n        onMouseLeave={() => setIsMouseDown(false)}\n      >\n        {grid.map((row, rowIndex) =>\n          row.map((isAlive, cellIndex) => (\n            <Cell\n              key={String(`${rowIndex}:${cellIndex}`)}\n              dimension={cellDimension}\n              coordinates={[cellIndex, rowIndex]}\n              isAlive={isAlive}\n              isClicked={isMouseDown}\n              toggleCell={toggleCell}\n            />\n          )),\n        )}\n      </ChakraGrid>\n    </Flex>\n  );\n};\n","import React from 'react';\nimport {\n  Box,\n  Button,\n  Flex,\n  Heading,\n  Text,\n  IconButton,\n  useBreakpointValue,\n  Menu,\n  MenuButton,\n  MenuList,\n  VStack,\n} from '@chakra-ui/react';\nimport {\n  FaPlay as PlayIcon,\n  FaPause as StopIcon,\n  FaBars as MenuIcon,\n} from 'react-icons/fa';\n\nimport { useGame } from '../hooks/game';\n\nexport const TopBar: React.FC = () => {\n  const {\n    gameIsRunning,\n    toggleGame,\n    generateRandomGame,\n    resetGame,\n  } = useGame();\n\n  const isScreenWide = useBreakpointValue({\n    base: false,\n    md: true,\n  });\n\n  const title = \"Conway's Game of Life\";\n\n  return (\n    <Box bg=\"blue.400\" px=\"24px\" w=\"100%\">\n      <Flex\n        as=\"header\"\n        w=\"100%\"\n        maxW={1180}\n        h=\"64px\"\n        mx=\"auto\"\n        align=\"center\"\n        justify=\"space-between\"\n      >\n        <Heading color=\"white\" size=\"lg\" fontWeight=\"medium\">\n          {title}\n        </Heading>\n\n        <Flex gridGap=\"2\">\n          {isScreenWide ? (\n            <Button\n              type=\"button\"\n              w=\"100px\"\n              onClick={() => toggleGame()}\n              size=\"lg\"\n              colorScheme={gameIsRunning ? 'red' : 'green'}\n            >\n              <Text\n                fontWeight=\"medium\"\n                color={gameIsRunning ? 'gray.800' : 'inherit'}\n              >\n                {gameIsRunning ? 'Stop' : 'Start'}\n              </Text>\n            </Button>\n          ) : (\n            <IconButton\n              colorScheme={gameIsRunning ? 'red' : 'green'}\n              type=\"button\"\n              aria-label=\"toggle-game\"\n              icon={gameIsRunning ? <StopIcon /> : <PlayIcon />}\n              size=\"lg\"\n              fontSize=\"20px\"\n              onClick={() => toggleGame()}\n            />\n          )}\n\n          {isScreenWide ? (\n            <>\n              <Button\n                type=\"button\"\n                w=\"100px\"\n                size=\"lg\"\n                colorScheme=\"blue\"\n                onClick={() => generateRandomGame()}\n                disabled={gameIsRunning}\n              >\n                <Text fontWeight=\"medium\">Generate</Text>\n              </Button>\n\n              <Button\n                type=\"button\"\n                w=\"100px\"\n                size=\"lg\"\n                colorScheme=\"blue\"\n                variant=\"solid\"\n                onClick={() => resetGame()}\n                disabled={gameIsRunning}\n              >\n                <Text fontWeight=\"medium\">Clear</Text>\n              </Button>\n            </>\n          ) : (\n            <Menu size=\"lg\">\n              <MenuButton\n                as={IconButton}\n                type=\"button\"\n                colorScheme=\"whiteAlpha\"\n                color=\"whiteAlpha.900\"\n                aria-label=\"menu-toggle\"\n                icon={<MenuIcon />}\n                size=\"lg\"\n                fontSize=\"20px\"\n                variant=\"ghost\"\n                disabled={gameIsRunning}\n              />\n\n              <MenuList minW=\"128px\" bg=\"transparent\" border=\"none\">\n                <VStack>\n                  <Button\n                    type=\"button\"\n                    w=\"100px\"\n                    size=\"md\"\n                    colorScheme=\"blue\"\n                    onClick={() => generateRandomGame()}\n                    disabled={gameIsRunning}\n                  >\n                    <Text fontWeight=\"medium\">Generate</Text>\n                  </Button>\n\n                  <Button\n                    type=\"button\"\n                    w=\"100px\"\n                    size=\"md\"\n                    colorScheme=\"blue\"\n                    onClick={() => resetGame()}\n                    disabled={gameIsRunning}\n                  >\n                    <Text fontWeight=\"medium\">Clear</Text>\n                  </Button>\n                </VStack>\n              </MenuList>\n            </Menu>\n          )}\n        </Flex>\n      </Flex>\n    </Box>\n  );\n};\n","import React from 'react';\nimport { Flex } from '@chakra-ui/react';\n\nexport const AppContainer: React.FC = ({ children }) => {\n  return (\n    <Flex flexDir=\"column\" h=\"100vh\" w=\"100vw\">\n      {children}\n    </Flex>\n  );\n};\n","import { extendTheme } from '@chakra-ui/react';\n\nexport const theme = extendTheme({\n  fonts: {\n    heading: 'Barlow, sans-serif',\n    body: 'Barlow, sans-serif',\n  },\n});\n","import React from 'react';\nimport { ChakraProvider } from '@chakra-ui/react';\n\nimport AppProvider from './hooks';\n\nimport { Grid } from './components/Grid';\nimport { TopBar } from './components/TopBar';\nimport { AppContainer } from './components/AppContainer';\n\nimport { theme } from './styles/theme';\n\nconst App: React.FC = () => {\n  return (\n    <ChakraProvider theme={theme}>\n      <AppProvider>\n        <AppContainer>\n          <TopBar />\n          <Grid />\n        </AppContainer>\n      </AppProvider>\n    </ChakraProvider>\n  );\n};\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport App from './App';\n\nexport function start() {\n  ReactDOM.render(\n    <React.StrictMode>\n      <App />\n    </React.StrictMode>,\n    document.getElementById('root'),\n  );\n}\n"],"sourceRoot":""}